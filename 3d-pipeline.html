<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software 3D Rendering Pipeline</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #ffffff; /* White background */
        }
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        // --- 1. DATA STRUCTURES ---

        /**
         * A simple class to represent a 3D vector or point.
         */
        class Vector3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
        }

        /**
         * A class to represent a 3D object with vertices and faces.
         */
        class Mesh {
            constructor(vertices, faces) {
                this.vertices = vertices; // Array of Vector3
                this.faces = faces;       // Array of index arrays
            }
        }

        // --- 2. THE SCENE ---

        // Define the 8 vertices of a cube centered at (0,0,0)
        const cubeVertices = [
            new Vector3(-1, -1, -1), // 0
            new Vector3( 1, -1, -1), // 1
            new Vector3( 1,  1, -1), // 2
            new Vector3(-1,  1, -1), // 3
            new Vector3(-1, -1,  1), // 4
            new Vector3( 1, -1,  1), // 5
            new Vector3( 1,  1,  1), // 6
            new Vector3(-1,  1,  1)  // 7
        ];

        // Define the 6 faces of the cube using vertex indices
        // Each face is a quadrilateral, defined by 4 vertex indices
        const cubeFaces = [
            [0, 1, 2, 3], // Front face
            [1, 5, 6, 2], // Right face
            [5, 4, 7, 6], // Back face
            [4, 0, 3, 7], // Left face
            [3, 2, 6, 7], // Top face
            [4, 5, 1, 0]  // Bottom face
        ];

        const cubeMesh = new Mesh(cubeVertices, cubeFaces);

        // --- 3. THE PIPELINE STAGES ---

        /**
         * Model Transformation: Rotates vertices around the Y and X axes.
         * This transforms the cube from its local space to the world space.
         * @param {Vector3} vertex - The vertex to transform.
         * @param {number} angleY - The rotation angle around the Y axis.
         * @param {number} angleX - The rotation angle around the X axis.
         * @returns {Vector3} The new, rotated vertex.
         */
        function modelTransform(vertex, angleY, angleX) {
            let x = vertex.x;
            let y = vertex.y;
            let z = vertex.z;
            
            // Rotation around Y-axis
            let cosY = Math.cos(angleY);
            let sinY = Math.sin(angleY);
            let tempX = x * cosY - z * sinY;
            let tempZ = x * sinY + z * cosY;
            x = tempX;
            z = tempZ;

            // Rotation around X-axis
            let cosX = Math.cos(angleX);
            let sinX = Math.sin(angleX);
            let tempY = y * cosX - z * sinX;
            tempZ = y * sinX + z * cosX;
            y = tempY;
            z = tempZ;

            return new Vector3(x, y, z);
        }

        /**
         * View Transformation: Positions the world relative to the camera.
         * Here, we simply move the object away from the camera along the Z-axis.
         * @param {Vector3} vertex - The vertex from world space.
         * @param {number} cameraDistance - The distance to move the vertex.
         * @returns {Vector3} The transformed vertex in view space.
         */
        function viewTransform(vertex, cameraDistance) {
            // To make the object visible, we push it away from the camera's origin (0,0,0).
            // A positive Z value is "into" the screen in a right-handed system.
            return new Vector3(vertex.x, vertex.y, vertex.z + cameraDistance);
        }

        /**
         * Projection Transformation: Projects a 3D point onto a 2D plane.
         * @param {Vector3} vertex - The vertex from view space.
         * @returns {Vector3} A 2D vector (z is unused) representing the screen coordinates.
         */
        function projectionTransform(vertex) {
            // Perspective Projection Math:
            // The projected x' and y' coordinates are found by dividing the
            // original x and y by the z coordinate. This simulates perspective,
            // where objects farther away (larger z) appear smaller.
            // A field of view (FOV) factor can be used to scale the result,
            // affecting the "lens" of the camera. A larger FOV is like a wider lens.
            const fov = 2; // Field of view factor
            const projectedX = (vertex.x * fov) / vertex.z;
            const projectedY = (vertex.y * fov) / vertex.z;
            return new Vector3(projectedX, projectedY, 0);
        }


        /**
         * Rasterization: Draws the wireframe faces to the canvas.
         * @param {CanvasRenderingContext2D} ctx - The 2D drawing context.
         * @param {Vector3[]} projectedVertices - The array of 2D projected points.
         * @param {number[][]} faces - The faces of the mesh.
         * @param {number} canvasWidth - The width of the canvas.
         * @param {number} canvasHeight - The height of the canvas.
         */
        function rasterize(ctx, projectedVertices, faces, canvasWidth, canvasHeight) {
            ctx.strokeStyle = '#000000'; // Black lines
            ctx.lineWidth = 2;

            faces.forEach(face => {
                ctx.beginPath();
                // Map from projected coordinates (-1 to 1) to screen coordinates.
                const startPoint = projectedVertices[face[0]];
                const screenX = startPoint.x * canvasWidth / 2 + canvasWidth / 2;
                const screenY = -startPoint.y * canvasHeight / 2 + canvasHeight / 2;
                ctx.moveTo(screenX, screenY);

                // Draw lines to the other vertices of the face
                for (let i = 1; i < face.length; i++) {
                    const nextPoint = projectedVertices[face[i]];
                    const nextScreenX = nextPoint.x * canvasWidth / 2 + canvasWidth / 2;
                    const nextScreenY = -nextPoint.y * canvasHeight / 2 + canvasHeight / 2;
                    ctx.lineTo(nextScreenX, nextScreenY);
                }
                
                // Close the path by drawing a line back to the start
                ctx.lineTo(screenX, screenY);
                ctx.stroke();
            });
        }
        
        // --- 4. THE RENDER LOOP ---

        window.onload = function() {
            const canvas = document.getElementById('renderCanvas');
            const ctx = canvas.getContext('2d');
            
            const canvasWidth = 600;
            const canvasHeight = 600;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            let angleY = 0;
            let angleX = 0;
            
            // Position the cube so it's visible in front of the camera.
            const cameraDistance = 5;

            function render() {
                // Clear the canvas for the new frame
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                
                // Update rotation angles for animation
                angleY += 0.01;
                angleX += 0.015;

                // --- Execute the rendering pipeline ---

                // 1. Apply model transformation to all vertices
                const rotatedVertices = cubeMesh.vertices.map(v => modelTransform(v, angleY, angleX));
                
                // 2. Apply view transformation
                const viewedVertices = rotatedVertices.map(v => viewTransform(v, cameraDistance));
                
                // 3. Apply projection transformation
                const projectedVertices = viewedVertices.map(v => projectionTransform(v));

                // 4. Rasterize the result to the canvas
                rasterize(ctx, projectedVertices, cubeMesh.faces, canvasWidth, canvasHeight);

                // Request the next frame
                requestAnimationFrame(render);
            }

            // Start the animation loop
            render();
        };
    </script>
</body>
</html>
